{"ast":null,"code":"import { EventDispatcher } from '../core/EventDispatcher.js';\nimport { MirroredRepeatWrapping, ClampToEdgeWrapping, RepeatWrapping, LinearEncoding, UnsignedByteType, RGBAFormat, LinearMipmapLinearFilter, LinearFilter, UVMapping } from '../constants.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { ImageUtils } from '../extras/ImageUtils.js';\nlet textureId = 0;\n\nclass Texture extends EventDispatcher {\n  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {\n    super();\n    Object.defineProperty(this, 'id', {\n      value: textureId++\n    });\n    this.uuid = MathUtils.generateUUID();\n    this.name = '';\n    this.image = image;\n    this.mipmaps = [];\n    this.mapping = mapping;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.magFilter = magFilter;\n    this.minFilter = minFilter;\n    this.anisotropy = anisotropy;\n    this.format = format;\n    this.internalFormat = null;\n    this.type = type;\n    this.offset = new Vector2(0, 0);\n    this.repeat = new Vector2(1, 1);\n    this.center = new Vector2(0, 0);\n    this.rotation = 0;\n    this.matrixAutoUpdate = true;\n    this.matrix = new Matrix3();\n    this.generateMipmaps = true;\n    this.premultiplyAlpha = false;\n    this.flipY = true;\n    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n    //\n    // Also changing the encoding after already used by a Material will not automatically make the Material\n    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\n    this.encoding = encoding;\n    this.version = 0;\n    this.onUpdate = null;\n  }\n\n  updateMatrix() {\n    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n  }\n\n  clone() {\n    return new this.constructor().copy(this);\n  }\n\n  copy(source) {\n    this.name = source.name;\n    this.image = source.image;\n    this.mipmaps = source.mipmaps.slice(0);\n    this.mapping = source.mapping;\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n    this.anisotropy = source.anisotropy;\n    this.format = source.format;\n    this.internalFormat = source.internalFormat;\n    this.type = source.type;\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.center.copy(source.center);\n    this.rotation = source.rotation;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrix.copy(source.matrix);\n    this.generateMipmaps = source.generateMipmaps;\n    this.premultiplyAlpha = source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    this.unpackAlignment = source.unpackAlignment;\n    this.encoding = source.encoding;\n    return this;\n  }\n\n  toJSON(meta) {\n    const isRootObject = meta === undefined || typeof meta === 'string';\n\n    if (!isRootObject && meta.textures[this.uuid] !== undefined) {\n      return meta.textures[this.uuid];\n    }\n\n    const output = {\n      metadata: {\n        version: 4.5,\n        type: 'Texture',\n        generator: 'Texture.toJSON'\n      },\n      uuid: this.uuid,\n      name: this.name,\n      mapping: this.mapping,\n      repeat: [this.repeat.x, this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      center: [this.center.x, this.center.y],\n      rotation: this.rotation,\n      wrap: [this.wrapS, this.wrapT],\n      format: this.format,\n      type: this.type,\n      encoding: this.encoding,\n      minFilter: this.minFilter,\n      magFilter: this.magFilter,\n      anisotropy: this.anisotropy,\n      flipY: this.flipY,\n      premultiplyAlpha: this.premultiplyAlpha,\n      unpackAlignment: this.unpackAlignment\n    };\n\n    if (this.image !== undefined) {\n      // TODO: Move to THREE.Image\n      const image = this.image;\n\n      if (image.uuid === undefined) {\n        image.uuid = MathUtils.generateUUID(); // UGH\n      }\n\n      if (!isRootObject && meta.images[image.uuid] === undefined) {\n        let url;\n\n        if (Array.isArray(image)) {\n          // process array of images e.g. CubeTexture\n          url = [];\n\n          for (let i = 0, l = image.length; i < l; i++) {\n            // check cube texture with data textures\n            if (image[i].isDataTexture) {\n              url.push(serializeImage(image[i].image));\n            } else {\n              url.push(serializeImage(image[i]));\n            }\n          }\n        } else {\n          // process single image\n          url = serializeImage(image);\n        }\n\n        meta.images[image.uuid] = {\n          uuid: image.uuid,\n          url: url\n        };\n      }\n\n      output.image = image.uuid;\n    }\n\n    if (!isRootObject) {\n      meta.textures[this.uuid] = output;\n    }\n\n    return output;\n  }\n\n  dispose() {\n    this.dispatchEvent({\n      type: 'dispose'\n    });\n  }\n\n  transformUv(uv) {\n    if (this.mapping !== UVMapping) return uv;\n    uv.applyMatrix3(this.matrix);\n\n    if (uv.x < 0 || uv.x > 1) {\n      switch (this.wrapS) {\n        case RepeatWrapping:\n          uv.x = uv.x - Math.floor(uv.x);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.x = uv.x < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n            uv.x = Math.ceil(uv.x) - uv.x;\n          } else {\n            uv.x = uv.x - Math.floor(uv.x);\n          }\n\n          break;\n      }\n    }\n\n    if (uv.y < 0 || uv.y > 1) {\n      switch (this.wrapT) {\n        case RepeatWrapping:\n          uv.y = uv.y - Math.floor(uv.y);\n          break;\n\n        case ClampToEdgeWrapping:\n          uv.y = uv.y < 0 ? 0 : 1;\n          break;\n\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n            uv.y = Math.ceil(uv.y) - uv.y;\n          } else {\n            uv.y = uv.y - Math.floor(uv.y);\n          }\n\n          break;\n      }\n    }\n\n    if (this.flipY) {\n      uv.y = 1 - uv.y;\n    }\n\n    return uv;\n  }\n\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n\n}\n\nTexture.DEFAULT_IMAGE = undefined;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.prototype.isTexture = true;\n\nfunction serializeImage(image) {\n  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    // default images\n    return ImageUtils.getDataURL(image);\n  } else {\n    if (image.data) {\n      // images of DataTexture\n      return {\n        data: Array.prototype.slice.call(image.data),\n        width: image.width,\n        height: image.height,\n        type: image.data.constructor.name\n      };\n    } else {\n      console.warn('THREE.Texture: Unable to serialize Texture.');\n      return {};\n    }\n  }\n}\n\nexport { Texture };","map":{"version":3,"sources":["C:/Users/Maxim.Karpov/cypress/react/veriboy/node_modules/three/src/textures/Texture.js"],"names":["EventDispatcher","MirroredRepeatWrapping","ClampToEdgeWrapping","RepeatWrapping","LinearEncoding","UnsignedByteType","RGBAFormat","LinearMipmapLinearFilter","LinearFilter","UVMapping","MathUtils","Vector2","Matrix3","ImageUtils","textureId","Texture","constructor","image","DEFAULT_IMAGE","mapping","DEFAULT_MAPPING","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","encoding","Object","defineProperty","value","uuid","generateUUID","name","mipmaps","internalFormat","offset","repeat","center","rotation","matrixAutoUpdate","matrix","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","version","onUpdate","updateMatrix","setUvTransform","x","y","clone","copy","source","slice","toJSON","meta","isRootObject","undefined","textures","output","metadata","generator","wrap","images","url","Array","isArray","i","l","length","isDataTexture","push","serializeImage","dispose","dispatchEvent","transformUv","uv","applyMatrix3","Math","floor","abs","ceil","needsUpdate","prototype","isTexture","HTMLImageElement","HTMLCanvasElement","ImageBitmap","getDataURL","data","call","width","height","console","warn"],"mappings":"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","sourcesContent":["import { EventDispatcher } from '../core/EventDispatcher.js';\nimport {\n\tMirroredRepeatWrapping,\n\tClampToEdgeWrapping,\n\tRepeatWrapping,\n\tLinearEncoding,\n\tUnsignedByteType,\n\tRGBAFormat,\n\tLinearMipmapLinearFilter,\n\tLinearFilter,\n\tUVMapping\n} from '../constants.js';\nimport { MathUtils } from '../math/MathUtils.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport { ImageUtils } from '../extras/ImageUtils.js';\n\nlet textureId = 0;\n\nclass Texture extends EventDispatcher {\n\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {\n\n\t\tsuper();\n\n\t\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.image = image;\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping;\n\n\t\tthis.wrapS = wrapS;\n\t\tthis.wrapT = wrapT;\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.anisotropy = anisotropy;\n\n\t\tthis.format = format;\n\t\tthis.internalFormat = null;\n\t\tthis.type = type;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\n\t\t//\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\n\t\t// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.\n\t\tthis.encoding = encoding;\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.image = source.image;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.encoding = source.encoding;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\tmapping: this.mapping,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\ttype: this.type,\n\t\t\tencoding: this.encoding,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( this.image !== undefined ) {\n\n\t\t\t// TODO: Move to THREE.Image\n\n\t\t\tconst image = this.image;\n\n\t\t\tif ( image.uuid === undefined ) {\n\n\t\t\t\timage.uuid = MathUtils.generateUUID(); // UGH\n\n\t\t\t}\n\n\t\t\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\n\n\t\t\t\tlet url;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\t// process array of images e.g. CubeTexture\n\n\t\t\t\t\turl = [];\n\n\t\t\t\t\tfor ( let i = 0, l = image.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t// check cube texture with data textures\n\n\t\t\t\t\t\tif ( image[ i ].isDataTexture ) {\n\n\t\t\t\t\t\t\turl.push( serializeImage( image[ i ].image ) );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\turl.push( serializeImage( image[ i ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// process single image\n\n\t\t\t\t\turl = serializeImage( image );\n\n\t\t\t\t}\n\n\t\t\t\tmeta.images[ image.uuid ] = {\n\t\t\t\t\tuuid: image.uuid,\n\t\t\t\t\turl: url\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\toutput.image = image.uuid;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\nTexture.DEFAULT_IMAGE = undefined;\nTexture.DEFAULT_MAPPING = UVMapping;\n\nTexture.prototype.isTexture = true;\n\nfunction serializeImage( image ) {\n\n\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t// default images\n\n\t\treturn ImageUtils.getDataURL( image );\n\n\t} else {\n\n\t\tif ( image.data ) {\n\n\t\t\t// images of DataTexture\n\n\t\t\treturn {\n\t\t\t\tdata: Array.prototype.slice.call( image.data ),\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\ttype: image.data.constructor.name\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Texture: Unable to serialize Texture.' );\n\t\t\treturn {};\n\n\t\t}\n\n\t}\n\n}\n\nexport { Texture };\n"]},"metadata":{},"sourceType":"module"}